<div class="uc-carousel cats-block" id="catsCarousel"
     data-autoplay="true"
     data-interval="4500"
     data-loop="true"
     data-swipe="true"
     data-progress-offset="150"
     data-pv-mobile="1"
     data-pv-tablet="2"
     data-pv-desktop="3"
     data-bp-tablet="480"
     data-bp-desktop="960">
  <div class="uc-viewport">
    <div class="uc-track">

      <!-- Столовые группы -->
      <div class="uc-slide">
        <a href="#" class="cat-bg-block">
          <div class="cat-bl bl1"></div>
          <div class="cat-bg-block-text">
            <p class="tile__title">Столовые группы</p>
          </div>
        </a>
      </div>
      
      <!-- Зеркала -->
      <div class="uc-slide">
        <a href="#" class="cat-bg-block">
          <div class="cat-bl bl2"></div>
          <div class="cat-bg-block-text">
            <p class="tile__title">Зеркала</p>
          </div>
        </a>
      </div>

      <!-- Зонирование -->
      <div class="uc-slide">
        <a href="#" class="cat-bg-block">
          <div class="cat-bl bl3"></div>
          <div class="cat-bg-block-text">
            <p class="tile__title">Зонирование</p>
          </div>
        </a>
      </div>

    </div>
  </div>

  <!-- Навигация -->
  <div class="uc-nav">
    <button class="uc-btn uc-prev" aria-label="Назад" type="button">
<svg xmlns="http://www.w3.org/2000/svg" width="18" height="8" viewBox="0 0 18 8" fill="none">
<path d="M17 3.76575C17.2761 3.76575 17.5 3.9896 17.5 4.26575C17.5 4.54189 17.2761 4.76575 17 4.76575V4.26575V3.76575ZM0.646447 4.6193C0.451184 4.42404 0.451184 4.10746 0.646447 3.91219L3.82843 0.730213C4.02369 0.534951 4.34027 0.534951 4.53553 0.730213C4.7308 0.925475 4.7308 1.24206 4.53553 1.43732L1.70711 4.26575L4.53553 7.09417C4.7308 7.28944 4.7308 7.60602 4.53553 7.80128C4.34027 7.99654 4.02369 7.99654 3.82843 7.80128L0.646447 4.6193ZM17 4.26575V4.76575H1V4.26575V3.76575H17V4.26575Z" fill="white"/>
</svg>
    </button>
    <button class="uc-btn uc-next" aria-label="Вперёд" type="button">
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="8" viewBox="0 0 18 8" fill="none">
<path d="M0.935913 3.76575C0.659771 3.76575 0.435913 3.9896 0.435913 4.26575C0.435913 4.54189 0.659771 4.76575 0.935913 4.76575V4.26575V3.76575ZM17.2895 4.6193C17.4847 4.42404 17.4847 4.10746 17.2895 3.91219L14.1075 0.730213C13.9122 0.534951 13.5956 0.534951 13.4004 0.730213C13.2051 0.925475 13.2051 1.24206 13.4004 1.43732L16.2288 4.26575L13.4004 7.09417C13.2051 7.28944 13.2051 7.60602 13.4004 7.80128C13.5956 7.99654 13.9122 7.99654 14.1075 7.80128L17.2895 4.6193ZM0.935913 4.26575V4.76575H16.9359V4.26575V3.76575H0.935913V4.26575Z" fill="white"/>
</svg>
    </button>
  </div>

  <!-- Точки -->
  <div class="uc-dots" aria-hidden="true"></div>
</div>

<style>
    .cats-block {
        width: 100%;
        max-width: 1000px;
        margin: 0 auto;
        position: relative;
    }
    
    @media (max-width: 640px) {
        .cats-block {
            width: 300px;
            margin-left: auto;
            margin-right: auto;
            display: block;
        }
        
        .cats-block .uc-viewport {
            width: 100%;
        }
        
        .cats-block .uc-track {
            margin-left: 0;
            margin-right: 0;
        }
    }
    
    .cats-block .uc-viewport {
        overflow: hidden;
        position: relative;
    }
    
    .cats-block .uc-track {
        display: flex;
        gap: 12px;
    }
    
    @media (max-width: 640px) {
        .cats-block .uc-track {
            gap: 0;
        }
    }
    
    .cats-block .uc-slide {
        flex: 0 0 auto;
        padding: 0;
    }
    
    .cat-bg-block {
        display: flex;
        height: 360px;
        padding: 0px;
        align-items: flex-end;
        position: relative;
        overflow: hidden;
        border-radius: 8px;
        text-decoration: none;
        color: inherit;
        width: 100%;
    }
    
    .cat-bg-block-text { 
        padding: 0px;
        position: absolute;
        bottom: 20px;
        left: 20px;
        z-index: 2;
    }
    
    .bl1 {
        background-image: url("https://raw.githubusercontent.com/weareneture/valonti/refs/heads/main/main/cat-bg-block/table.jpg");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
    }
    
    .bl2 {
        background-image: url("https://raw.githubusercontent.com/weareneture/valonti/refs/heads/main/main/cat-bg-block/mirror.jpg");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
    }
    
    .bl3 {
        background-image: url("https://raw.githubusercontent.com/weareneture/valonti/refs/heads/main/main/cat-bg-block/par.jpg");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
    }
    
    .tile__title {
        color: #FFF;
        font-family: "RF Dewi";
        font-size: 14px;
        font-style: normal;
        font-weight: 400;
        line-height: 18px;
    }
    
    .cat-bl {
        width: 100%;
        height: 100%;
        filter: grayscale(100%);
        transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                    filter 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .cat-bg-block:hover .cat-bl {
        transform: scale(1.1);
        filter: grayscale(0%);
    }
</style>

<script>
    (function(){
      document.querySelectorAll('.uc-carousel').forEach(root=>{
        if (root.dataset.ucReady === '1') return;
        root.dataset.ucReady = '1';
        initCarousel(root);
      });
    
      if (!document.getElementById('uc-paused-style')){
        const st = document.createElement('style');
        st.id = 'uc-paused-style';
        st.textContent = '.uc-paused .uc-dot.is-active::after{animation-play-state:paused!important;}';
        document.head.appendChild(st);
      }
    
      function initCarousel(root){
        const autoplay  = root.dataset.autoplay === 'true';
        const interval  = parseInt(root.dataset.interval||'4000',10);
        const loop      = root.dataset.loop === 'true';
        const swipe     = root.dataset.swipe === 'true';
        const aspect    = (root.dataset.aspect || '').trim();
        const bpTablet  = parseInt(root.dataset.bpTablet  || '480', 10);
        const bpDesktop = parseInt(root.dataset.bpDesktop || '960', 10);
        const pvMobile  = parseInt(root.dataset.pvMobile  || '1',   10);
        const pvTablet  = parseInt(root.dataset.pvTablet  || '2',   10);
        const pvDesktop = parseInt(root.dataset.pvDesktop || '3',   10);
        const progressOffset = parseInt(root.dataset.progressOffset || '180', 10);
        const singleCenter = root.dataset.singleCenter === 'true';
        const startTitle = (root.dataset.startTitle || '').toLowerCase();
        const startIndexAttr = root.dataset.startIndex ? parseInt(root.dataset.startIndex,10) : null;
    
        root.style.setProperty('--uc-interval', interval + 'ms');
        if (aspect) root.style.setProperty('--uc-aspect', aspect);
    
        const track    = root.querySelector('.uc-track');
        const prevBtn  = root.querySelector('.uc-prev');
        const nextBtn  = root.querySelector('.uc-next');
        const dotsWrap = root.querySelector('.uc-dots');
        const viewport = root.querySelector('.uc-viewport');
        let indicator  = null;
    
        track.style.display='flex';
        track.style.flexWrap='nowrap';
        track.style.alignItems='stretch';
        track.style.willChange='transform';
        
        // Учитываем gap для карусели cats-block
        const hasGap = root.classList.contains('cats-block');
        track.style.marginLeft='0px';
        track.style.marginRight='0px';
        
        // Gap устанавливается через CSS, не через JS, чтобы медиа-запросы работали
    
        root.querySelectorAll('.uc-media img, .cat-bl').forEach(img=>{
          img.setAttribute('draggable','false');
          img.addEventListener('dragstart', e=>e.preventDefault());
        });
        track.addEventListener('dragstart', e=>e.preventDefault());
    
        let perView = 1, index = 0, slideW = 0, isAnimating = false;
        let manualPause = false;
        let tickTimer = null;
    
        const baseSlides = () => Array.from(track.querySelectorAll(':scope > .uc-slide:not(.uc-clone)'));
    
        function setTransform(){
          // Учитываем gap при расчете смещения
          const gap = (hasGap && perView > 1) ? 12 : 0;
          const x = Math.round(-index * (slideW + gap));
          track.style.transform = `translate3d(${x}px,0,0)`;
        }
        function jumpTo(i, withAnim=true){
          track.style.transition = withAnim ? 'transform .45s ease' : 'none';
          index = i; setTransform();
        }
    
        function computePerView(w){
          if (w >= bpDesktop) return pvDesktop;
          if (w >= bpTablet)  return pvTablet;
          return pvMobile;
        }
    
        function measure(){
          const w = Math.max(1, root.clientWidth);
          perView = computePerView(w);
          
          // Учитываем gap при расчете ширины слайда
          if (hasGap && perView > 1) {
            const gapTotal = 12 * (perView - 1);
            slideW = (w - gapTotal) / perView;
          } else {
            slideW = w / perView;
          }
    
          // ширины слайдов
          track.querySelectorAll(':scope > .uc-slide').forEach(s=>{
            s.style.width = slideW + 'px';
            s.style.flex='0 0 auto';
            s.style.minWidth='0';
          });
    
          // НОВОЕ: «один по центру» — даём симметричные паддинги вьюпорту
          if (singleCenter && perView >= 2){
            const pad = Math.round((w - slideW) / 2);
            viewport.style.boxSizing = 'border-box';
            viewport.style.paddingLeft  = pad + 'px';
            viewport.style.paddingRight = pad + 'px';
          } else {
            viewport.style.paddingLeft  = '0px';
            viewport.style.paddingRight = '0px';
          }
    
          jumpTo(index, false);
        }
    
        function cloneSlide(slide){ const cl = slide.cloneNode(true); cl.classList.add('uc-clone'); return cl; }
        function buildClones(){
          track.querySelectorAll(':scope > .uc-clone').forEach(n=>n.remove());
          const base = baseSlides(); if (!base.length) return;
          const needed = Math.min(base.length, perView + 1);
          const head = base.slice(0, needed).map(cloneSlide);
          const tail = base.slice(-needed).map(cloneSlide);
          tail.forEach(cl=>track.insertBefore(cl, track.firstChild));
          head.forEach(cl=>track.appendChild(cl));
          index = needed;
        }
        
        function getStartRealIndex(){
      const slides = baseSlides();
      if (Number.isInteger(startIndexAttr) && startIndexAttr >= 0 && startIndexAttr < slides.length){
        return startIndexAttr;
      }
      if (startTitle){
        const i = slides.findIndex(s=>{
          const t = s.querySelector('.uc-title, .tile__title')?.textContent?.trim().toLowerCase() || '';
          return t.includes(startTitle);
        });
        if (i >= 0) return i;
      }
      return 0;
    }
    
    
        function activeRealIndex(){
          const realCount  = baseSlides().length;
          const clonesLeft = Math.min(realCount, perView + 1);
          let realIndex = (index - clonesLeft) % realCount;
          if (realIndex < 0) realIndex += realCount;
          return { realIndex, realCount, clonesLeft };
        }
    
        function buildDots(){
          if (!dotsWrap) return;
          dotsWrap.innerHTML = '';
          const { realCount } = activeRealIndex();
          for(let i=0;i<realCount;i++){
            const b = document.createElement('button');
            b.className='uc-dot'; b.type='button';
            b.addEventListener('click', ()=>{
              const { clonesLeft } = activeRealIndex();
              clearTick();
              jumpTo(clonesLeft + i, true);
              updateDots();
              if (!manualPause) scheduleTick();
            });
            dotsWrap.appendChild(b);
          }
          indicator = document.createElement('span');
          indicator.className='uc-dots-indicator';
          dotsWrap.appendChild(indicator);
        }
    
        function updateDots(){
          if (!dotsWrap) return;
          const dots = dotsWrap.querySelectorAll('.uc-dot'); if (!dots.length) return;
          const { realIndex } = activeRealIndex();
          dots.forEach(d=>{ d.classList.remove('is-active'); d.offsetWidth; });
          const activeDot = dots[realIndex];
          if (activeDot){
            activeDot.classList.add('is-active');
            if (indicator){
              const center = activeDot.offsetLeft + activeDot.offsetWidth/2;
              indicator.style.left  = center + 'px';
              indicator.style.width = Math.max(38, activeDot.offsetWidth+12) + 'px';
              indicator.style.height= Math.max(22, activeDot.offsetHeight+14) + 'px';
            }
          }
          root.classList.toggle('uc-paused', manualPause);
        }
    
        function snapIfLooped(){
          if (!loop) return;
          const total = track.querySelectorAll(':scope > .uc-slide').length;
          const { realCount } = activeRealIndex();
          const edge = Math.min(realCount, perView + 1);
          if (index >= total - edge) jumpTo(index - realCount, false);
          else if (index < edge)     jumpTo(index + realCount, false);
        }
    
        function next(step=1){
          if (isAnimating) return;
          isAnimating = true;
          clearTick();
          jumpTo(index + step, true);
          setTimeout(()=>{ snapIfLooped(); updateDots(); isAnimating = false; if (!manualPause && autoplay) scheduleTick(); }, 460);
        }
        function prev(step=1){
          if (isAnimating) return;
          isAnimating = true;
          clearTick();
          jumpTo(index - step, true);
          setTimeout(()=>{ snapIfLooped(); updateDots(); isAnimating = false; if (!manualPause && autoplay) scheduleTick(); }, 460);
        }
    
        // Autoplay (timeout + «фора» прогрессу)
        function clearTick(){ if (tickTimer){ clearTimeout(tickTimer); tickTimer = null; } }
        function scheduleTick(){ clearTick(); if (!autoplay || manualPause) return; tickTimer = setTimeout(()=>next(1), interval + progressOffset); }
        function stopAutoplay(){ clearTick(); }
        function startAutoplay(){ if (!autoplay || manualPause) return; scheduleTick(); }
        function setManualPause(on){ manualPause = !!on; manualPause ? stopAutoplay() : startAutoplay(); updateDots(); }
        function toggleManualPause(){ setManualPause(!manualPause); }
    
        // Стрелки
        if (prevBtn){
          prevBtn.addEventListener('click', ()=>{ prev(1); });
          prevBtn.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); prev(1); }});
          prevBtn.addEventListener('mouseenter', stopAutoplay);
          prevBtn.addEventListener('mouseleave', startAutoplay);
          prevBtn.addEventListener('focusin',  stopAutoplay);
          prevBtn.addEventListener('focusout', startAutoplay);
          prevBtn.addEventListener('touchstart', stopAutoplay, {passive:true});
          prevBtn.addEventListener('touchend', ()=>setTimeout(startAutoplay, 50), {passive:true});
        }
        if (nextBtn){
          nextBtn.addEventListener('click', ()=>{ next(1); });
          nextBtn.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); next(1); }});
          nextBtn.addEventListener('mouseenter', stopAutoplay);
          nextBtn.addEventListener('mouseleave', startAutoplay);
          nextBtn.addEventListener('focusin',  stopAutoplay);
          nextBtn.addEventListener('focusout', startAutoplay);
          nextBtn.addEventListener('touchstart', stopAutoplay, {passive:true});
          nextBtn.addEventListener('touchend', ()=>setTimeout(startAutoplay, 50), {passive:true});
        }
    
        // Swipe / Drag + Tap-to-Pause
        if (swipe && viewport){
          let startX=0,startY=0,curX=0,curY=0,dragging=false,downTs=0;
          viewport.style.touchAction='pan-y';
          viewport.addEventListener('pointerdown',(e)=>{
            if (e.pointerType==='mouse') e.preventDefault();
            dragging=true; startX=curX=e.clientX; startY=curY=e.clientY; downTs=Date.now();
            track.style.transition='none'; viewport.setPointerCapture(e.pointerId); stopAutoplay(); root.classList.add('uc-dragging');
          },{passive:false});
          viewport.addEventListener('pointermove',(e)=>{
            if(!dragging) return; curX=e.clientX; curY=e.clientY;
            const gap = (hasGap && perView > 1) ? 12 : 0;
            const baseX=-index*(slideW + gap);
            track.style.transform=`translate3d(${Math.round(baseX+dx)}px,0,0)`; e.preventDefault();
          },{passive:false});
          const endDrag=()=>{
            if(!dragging) return; dragging=false; root.classList.remove('uc-dragging');
            const dx=curX-startX, dy=curY-startY, dist=Math.hypot(dx,dy), dt=Date.now()-downTs;
            const swipeThreshold=Math.max(40, slideW*0.15), tapDist=8, tapTime=250;
            if(dist<=tapDist && dt<=tapTime){ toggleManualPause(); jumpTo(index,true); }
            else { if(Math.abs(dx)>=swipeThreshold && Math.abs(dx)>Math.abs(dy)) (dx<0?next(1):prev(1)); else jumpTo(index,true);
                   if(!manualPause) scheduleTick(); }
          };
          viewport.addEventListener('pointerup', endDrag);
          viewport.addEventListener('pointercancel', endDrag);
          viewport.addEventListener('pointerleave', endDrag);
        }
    
        const doLayout = ()=>{
      measure();
      buildClones();
      buildDots();
    
      const realCount  = baseSlides().length;
      const clonesLeft = Math.min(realCount, perView + 1);
    
      let targetRealIndex;
      if (!root.__uc_inited){
        targetRealIndex = getStartRealIndex();
        root.__uc_inited = true;
      } else {
        targetRealIndex = activeRealIndex().realIndex;
      }
    
      jumpTo(clonesLeft + targetRealIndex, false);
      updateDots();
      if (!manualPause) scheduleTick();
    };
    
        if ('ResizeObserver' in window){
          const ro=new ResizeObserver(()=>doLayout()); ro.observe(root);
        } else {
          let rAf; window.addEventListener('resize',()=>{ cancelAnimationFrame(rAf); rAf=requestAnimationFrame(doLayout); });
        }
        document.addEventListener('visibilitychange', ()=>{ document.hidden ? stopAutoplay() : (!manualPause && scheduleTick()); });
    
        doLayout();
        startAutoplay();
      }
    })();
    </script>