<section class="section__recommendations">
    <div class="container__recommendations">
      <div class="recommendations__slider" data-recommendations-slider>
        <button class="recommendations__nav recommendations__nav--prev" type="button" aria-label="Предыдущий">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="8" viewBox="0 0 18 8" fill="none">
                <path d="M17 3.76575C17.2761 3.76575 17.5 3.9896 17.5 4.26575C17.5 4.54189 17.2761 4.76575 17 4.76575V4.26575V3.76575ZM0.646447 4.6193C0.451184 4.42404 0.451184 4.10746 0.646447 3.91219L3.82843 0.730213C4.02369 0.534951 4.34027 0.534951 4.53553 0.730213C4.7308 0.925475 4.7308 1.24206 4.53553 1.43732L1.70711 4.26575L4.53553 7.09417C4.7308 7.28944 4.7308 7.60602 4.53553 7.80128C4.34027 7.99654 4.02369 7.99654 3.82843 7.80128L0.646447 4.6193ZM17 4.26575V4.76575H1V4.26575V3.76575H17V4.26575Z" fill="white"/>
              </svg>
        </button>
        
        <div class="recommendations__track" data-recommendations-track>
          <div class="recommendations__list" data-recommendations-list>
            <!-- Карточки будут добавлены через JS -->
          </div>
        </div>
        
        <button class="recommendations__nav recommendations__nav--next" type="button" aria-label="Следующий">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="8" viewBox="0 0 18 8" fill="none">
                <path d="M0.935913 3.76575C0.659771 3.76575 0.435913 3.9896 0.435913 4.26575C0.435913 4.54189 0.659771 4.76575 0.935913 4.76575V4.26575V3.76575ZM17.2895 4.6193C17.4847 4.42404 17.4847 4.10746 17.2895 3.91219L14.1075 0.730213C13.9122 0.534951 13.5956 0.534951 13.4004 0.730213C13.2051 0.925475 13.2051 1.24206 13.4004 1.43732L16.2288 4.26575L13.4004 7.09417C13.2051 7.28944 13.2051 7.60602 13.4004 7.80128C13.5956 7.99654 13.9122 7.99654 14.1075 7.80128L17.2895 4.6193ZM0.935913 4.26575V4.76575H16.9359V4.26575V3.76575H0.935913V4.26575Z" fill="white"/>
              </svg>
        </button>
      </div>
    </div>
</section>

<script>
    // Функция инициализации слайдера
    async function initRecommendationsSlider() {
      const PRICES_URL = 'https://raw.githubusercontent.com/weareneture/valonti/refs/heads/main/catalog/price-update/prices.json';
      
      // Базовые данные рекомендаций (все модели из tables-info-2.html)
      const recommendationsBase = [
        {
          image: 'https://raw.githubusercontent.com/weareneture/valonti/refs/heads/main/catalog/img/belahis.png',
          category: 'Журнальный стол',
          title: 'Belahis',
          productId: 'belahis',
          price: 'Загрузка...',
          link: 'https://valonti.ru/catalog/mini-tables/belahis'
        },
        {
          image: 'https://raw.githubusercontent.com/weareneture/valonti/refs/heads/main/catalog/img/axilur-maxi.png',
          category: 'Журнальный стол',
          title: 'Axilur Maxi',
          productId: 'axilur-maxi',
          price: 'Загрузка...',
          link: 'https://valonti.ru/catalog/mini-tables/axilur-maxi'
        },
        {
          image: 'https://raw.githubusercontent.com/weareneture/valonti/refs/heads/main/catalog/img/axilur-mini.png',
          category: 'Журнальный стол',
          title: 'Axilur Mini',
          productId: 'axilur-mini',
          price: 'Загрузка...',
          link: 'https://valonti.ru/catalog/mini-tables/axilur-mini'
        },
        {
          image: 'https://raw.githubusercontent.com/weareneture/valonti/refs/heads/main/catalog/img/alurax.png',
          category: 'Журнальный стол',
          title: 'Alurax',
          productId: 'alurax',
          price: 'Загрузка...',
          link: 'https://valonti.ru/catalog/mini-tables/alurax'
        },
        {
          image: 'https://raw.githubusercontent.com/weareneture/valonti/refs/heads/main/catalog/img/jadorex.png',
          category: 'Журнальный стол',
          title: 'Jadorex',
          productId: 'jadorex',
          price: 'Загрузка...',
          link: 'https://valonti.ru/catalog/mini-tables/jadorex'
        },
        {
          image: 'https://raw.githubusercontent.com/weareneture/valonti/refs/heads/main/catalog/img/velarion.png',
          category: 'Журнальный стол',
          title: 'Velarion',
          productId: 'velarion',
          price: 'Загрузка...',
          link: 'https://valonti.ru/catalog/mini-tables/velarion'
        },
        {
          image: 'https://raw.githubusercontent.com/weareneture/valonti/refs/heads/main/catalog/img/estrellum.png',
          category: 'Журнальный стол',
          title: 'Estrellum',
          productId: 'estrellum',
          price: 'Загрузка...',
          link: 'https://valonti.ru/catalog/mini-tables/estrellum'
        },
        {
          image: 'https://raw.githubusercontent.com/weareneture/valonti/refs/heads/main/catalog/img/firmissum.png',
          category: 'Журнальный стол',
          title: 'Firmissum',
          productId: 'firmissum',
          price: 'Загрузка...',
          link: 'https://valonti.ru/catalog/mini-tables/firmissum'
        },
        {
          image: 'https://raw.githubusercontent.com/weareneture/valonti/refs/heads/main/catalog/img/akilum.png',
          category: 'Журнальный стол',
          title: 'Akilum',
          productId: 'akilum',
          price: 'Загрузка...',
          link: 'https://valonti.ru/catalog/mini-tables/akilum'
        },
        {
          image: 'https://raw.githubusercontent.com/weareneture/valonti/refs/heads/main/catalog/img/krabos.png',
          category: 'Журнальный стол',
          title: 'Krabos',
          productId: 'krabos',
          price: 'Загрузка...',
          link: 'https://valonti.ru/catalog/mini-tables/krabos'
        },
      ];
      
      // Загружаем цены из JSON
      let pricesData = {};
      try {
        const response = await fetch(PRICES_URL + '?t=' + Date.now());
        pricesData = await response.json();
      } catch (error) {
        console.error('Ошибка загрузки цен:', error);
      }
      
      // Обновляем цены в рекомендациях
      const recommendations = recommendationsBase.map(item => ({
        ...item,
        price: pricesData.prices && pricesData.prices[item.productId] 
          ? pricesData.prices[item.productId] 
          : item.price
      }));
    
      const listEl = document.querySelector('[data-recommendations-list]');
      const prevBtn = document.querySelector('.recommendations__nav--prev');
      const nextBtn = document.querySelector('.recommendations__nav--next');
      const trackEl = document.querySelector('[data-recommendations-track]');
      const sliderEl = document.querySelector('[data-recommendations-slider]');
    
      if (!listEl || !prevBtn || !nextBtn || !sliderEl) {
        // Если элементы не найдены, пробуем еще раз через небольшую задержку (для Tilda)
        setTimeout(initRecommendationsSlider, 100);
        return;
      }
    
      let index = 0; // индекс с учетом клонов
      let isAnimating = false;
      
      const getIsMobile = () => window.matchMedia('(max-width: 768px)').matches;
      const getItemsPerView = () => getIsMobile() ? 1 : 2;
      
      // Получаем только реальные слайды (без клонов)
      const getBaseSlides = () => Array.from(listEl.querySelectorAll(':scope > .recommendations__item:not(.recommendations__clone)'));
      
      // Получаем все слайды (включая клоны)
      const getAllSlides = () => Array.from(listEl.querySelectorAll(':scope > .recommendations__item'));
    
      const createCard = (item) => {
        const card = document.createElement('a');
        card.href = item.link;
        card.className = 'recommendations__item model__item';
        card.draggable = false;
        card.innerHTML = `
          <img src="${item.image}" alt="${item.title}" class="model__img" draggable="false">
          <div class="model__content">
            <div class="model__content__left">
              <p class="model__catname">${item.category}</p>
              <h2 class="model__title">${item.title}</h2>
            </div>
            <div class="model__content__right">
              <p class="model__price">${item.price}</p>
            </div>
          </div>
        `;
        return card;
      };
    
      const renderItems = () => {
        listEl.innerHTML = '';
        // Рендерим реальные слайды
        recommendations.forEach((item) => {
          const card = createCard(item);
          listEl.appendChild(card);
        });
      };
    
      const cloneCard = (card) => {
        const clone = card.cloneNode(true);
        clone.classList.add('recommendations__clone');
        return clone;
      };
    
      const buildClones = () => {
        // Удаляем старые клоны
        listEl.querySelectorAll(':scope > .recommendations__clone').forEach(clone => clone.remove());
        
        const baseSlides = getBaseSlides();
        if (!baseSlides.length) return;
        
        const isMobile = getIsMobile();
        
        // На мобилке не создаем клоны - простой слайдер без бесконечности
        if (isMobile) {
          index = 0; // Начинаем с первого слайда
          return;
        }
        
        // На десктопе создаем клоны для бесконечного эффекта
        const perView = getItemsPerView();
        const needed = Math.min(baseSlides.length, perView + 1);
        
        // Клоны в конце (первые N слайдов) - добавляем в конец для бесконечного скролла вправо
        const headClones = baseSlides.slice(0, needed).map(cloneCard);
        headClones.forEach(clone => listEl.appendChild(clone));
        
        // Клоны в начале (последние N слайдов) - добавляем в начало для бесконечного скролла влево
        const tailClones = baseSlides.slice(-needed).map(cloneCard);
        tailClones.forEach(clone => listEl.insertBefore(clone, listEl.firstChild));
        
        // Устанавливаем начальный индекс на первый реальный слайд (после клонов слева)
        index = needed;
      };
    
      const setTransform = (instant = false) => {
        const isMobile = getIsMobile();
        const gap = isMobile ? 8 : 20;
        
        if (!trackEl || trackEl.offsetWidth === 0) {
          requestAnimationFrame(() => setTransform(instant));
          return;
        }
        
        // Получаем слайды (на мобилке только реальные, на десктопе включая клоны)
        const slides = isMobile ? getBaseSlides() : getAllSlides();
        if (slides.length === 0) {
          requestAnimationFrame(() => setTransform(instant));
          return;
        }
        
        const firstSlide = slides[0];
        if (!firstSlide || firstSlide.offsetWidth === 0) {
          requestAnimationFrame(() => setTransform(instant));
          return;
        }
        
        // Простой расчет для всех устройств
        const slideWidth = firstSlide.offsetWidth;
        const translateX = -index * (slideWidth + gap);
        
        if (instant) {
          listEl.style.transition = 'none';
        } else {
          listEl.style.transition = 'transform 0.4s ease';
        }
        
        listEl.style.transform = `translateX(${translateX}px)`;
      };
    
      const snapIfLooped = () => {
        // На мобилке не используем бесконечный слайдер
        if (getIsMobile()) return;
        
        const baseSlides = getBaseSlides();
        const realCount = baseSlides.length;
        if (!realCount) return;
        
        const perView = getItemsPerView();
        const edge = Math.min(realCount, perView + 1);
        const total = getAllSlides().length;
        
        // Если достигли конца клонов справа - перепрыгиваем на начало реальных
        if (index >= total - edge) {
          index = index - realCount;
          setTransform(true);
        }
        // Если достигли начала клонов слева - перепрыгиваем на конец реальных
        else if (index < edge) {
          index = index + realCount;
          setTransform(true);
        }
      };
    
      const goPrev = (step = 1) => {
        if (isAnimating || isDragging) return;
        isAnimating = true;
        
        const baseSlides = getBaseSlides();
        const realCount = baseSlides.length;
        
        // На мобилке просто уменьшаем индекс с проверкой границ
        if (getIsMobile()) {
          index = Math.max(0, index - step);
        } else {
          index -= step;
        }
        
        setTransform();
        setTimeout(() => {
          snapIfLooped();
          isAnimating = false;
        }, 400);
      };
    
      const goNext = (step = 1) => {
        if (isAnimating || isDragging) return;
        isAnimating = true;
        
        const baseSlides = getBaseSlides();
        const realCount = baseSlides.length;
        
        // На мобилке просто увеличиваем индекс с проверкой границ
        if (getIsMobile()) {
          index = Math.min(realCount - 1, index + step);
        } else {
          index += step;
        }
        
        setTransform();
        setTimeout(() => {
          snapIfLooped();
          isAnimating = false;
        }, 400);
      };
    
      // Обработчики для стрелок
      prevBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        goPrev();
      });
      
      nextBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        goNext();
      });
    
      // Drag & Drop для десктопа и свайп для мобилки
      let dragStartX = 0;
      let dragStartY = 0;
      let dragCurrentX = 0;
      let dragCurrentY = 0;
      let isDragging = false;
      let startTranslateX = 0;
    
      const onPointerDown = (e) => {
        if (e.pointerType === 'mouse' && e.button !== 0) return;
        if (isAnimating) return;
        
        // Игнорируем клики на кнопках навигации
        if (e.target && typeof e.target.closest === 'function' && e.target.closest('.recommendations__nav')) return;
        
        // Отключаем стандартное поведение для ссылок и изображений только на touch устройствах
        // На мобилке не блокируем сразу, чтобы не мешать скроллу
        const isTouch = e.pointerType === 'touch' || e.pointerType === 'pen';
        if (!isTouch) {
          e.preventDefault();
        }
        
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        dragCurrentX = e.clientX;
        dragCurrentY = e.clientY;
        
        // Получаем текущую позицию из transform (учитывает центрирование на мобилке)
        const transform = listEl.style.transform;
        const match = transform.match(/translateX\((-?\d+\.?\d*)px\)/);
        startTranslateX = match ? parseFloat(match[1]) : 0;
        
        listEl.classList.add('dragging');
        sliderEl.classList.add('dragging');
        listEl.style.transition = 'none'; // отключаем анимацию при drag
        try { sliderEl.setPointerCapture(e.pointerId); } catch (_) {}
      };
    
      const onPointerMove = (e) => {
        if (!isDragging) return;
        
        dragCurrentX = e.clientX;
        dragCurrentY = e.clientY;
        const deltaX = dragCurrentX - dragStartX;
        const deltaY = dragCurrentY - dragStartY;
        
        // На мобилке проверяем, что это горизонтальное движение
        const isTouch = e.pointerType === 'touch' || e.pointerType === 'pen';
        if (isTouch) {
          // Блокируем скролл только если горизонтальное движение больше вертикального
          if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 5) {
            e.preventDefault();
          }
        } else {
          e.preventDefault();
        }
        
        const newTranslateX = startTranslateX + deltaX;
        listEl.style.transform = `translateX(${newTranslateX}px)`;
      };
    
    
      const onPointerUp = (e) => {
        if (!isDragging) return;
        isDragging = false;
        listEl.classList.remove('dragging');
        sliderEl.classList.remove('dragging');
    
        const dx = dragCurrentX - dragStartX;
        const dy = dragCurrentY - dragStartY;
        const threshold = 30; // минимальное расстояние для переключения на мобилке
        
        // Проверяем, что движение было преимущественно горизонтальным
        const isHorizontal = Math.abs(dx) > Math.abs(dy);
        const isMobile = getIsMobile();
        
        if (isHorizontal && Math.abs(dx) > threshold) {
          // Это был горизонтальный свайп - переключаем слайдер
          e.preventDefault();
          if (dx < 0) goNext();
          else goPrev();
        } else {
          // Малое движение или вертикальное - это был клик/скролл
          let clickedCard = null;
          if (e.target && typeof e.target.closest === 'function') {
            clickedCard = e.target.closest('.recommendations__item');
          } else if (e.target) {
            // Fallback для старых браузеров
            let el = e.target;
            while (el && el !== document) {
              if (el.classList && el.classList.contains('recommendations__item')) {
                clickedCard = el;
                break;
              }
              el = el.parentElement;
            }
          }
          
          if (clickedCard && !clickedCard.classList.contains('recommendations__clone') && Math.abs(dx) < 10) {
            // Переход по ссылке только для реальных карточек и только если не было свайпа
            setTimeout(() => {
              if (clickedCard.href) {
                window.location.href = clickedCard.href;
              }
            }, 10);
          } else {
            // Возвращаем на место
            setTransform();
          }
        }
      };
    
      // Обработчики на всю секцию слайдера для drag & drop
      // Игнорируем только клики на кнопках навигации
      const handlePointerDown = (e) => {
        // Игнорируем клики на кнопках навигации
        if (e.target.closest('.recommendations__nav')) return;
        onPointerDown(e);
      };
      
      sliderEl.addEventListener('pointerdown', handlePointerDown, { passive: false });
      // Также добавляем touch события для лучшей совместимости на мобилке
      sliderEl.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1 && !isDragging && !isAnimating) {
          const touch = e.touches[0];
          const target = e.target;
          // Создаем объект события, совместимый с pointer событиями
          const fakeEvent = {
            pointerType: 'touch',
            clientX: touch.clientX,
            clientY: touch.clientY,
            button: 0,
            target: target,
            preventDefault: () => e.preventDefault(),
            stopPropagation: () => e.stopPropagation()
          };
          // Добавляем closest метод если его нет
          if (!fakeEvent.target.closest) {
            fakeEvent.target.closest = function(selector) {
              let el = this;
              while (el && el !== document) {
                if (el.matches && el.matches(selector)) return el;
                el = el.parentElement;
              }
              return null;
            };
          }
          handlePointerDown(fakeEvent);
        }
      }, { passive: false });
      
      // Обработчики на document для корректной работы drag
      const handlePointerMove = (e) => {
        onPointerMove(e);
      };
      
      const handlePointerUp = (e) => {
        onPointerUp(e);
      };
      
      document.addEventListener('pointermove', handlePointerMove, { passive: false });
      document.addEventListener('pointerup', handlePointerUp, { passive: false });
      
      // Touch события для мобилки
      document.addEventListener('touchmove', (e) => {
        if (isDragging && e.touches.length === 1) {
          const touch = e.touches[0];
          const fakeEvent = {
            pointerType: 'touch',
            clientX: touch.clientX,
            clientY: touch.clientY,
            preventDefault: () => e.preventDefault()
          };
          handlePointerMove(fakeEvent);
        }
      }, { passive: false });
      
      document.addEventListener('touchend', (e) => {
        if (isDragging) {
          const touch = e.changedTouches[0];
          const target = e.target;
          const fakeEvent = {
            pointerType: 'touch',
            clientX: touch.clientX,
            clientY: touch.clientY,
            target: target,
            preventDefault: () => e.preventDefault()
          };
          // Добавляем closest метод если его нет
          if (!fakeEvent.target.closest) {
            fakeEvent.target.closest = function(selector) {
              let el = this;
              while (el && el !== document) {
                if (el.matches && el.matches(selector)) return el;
                el = el.parentElement;
              }
              return null;
            };
          }
          handlePointerUp(fakeEvent);
        }
      }, { passive: false });
      
      document.addEventListener('touchcancel', () => { 
        if (isDragging) {
          isDragging = false;
          listEl.classList.remove('dragging');
          sliderEl.classList.remove('dragging');
          setTransform();
        }
      });
      
      document.addEventListener('pointercancel', () => { 
        if (isDragging) {
          isDragging = false;
          listEl.classList.remove('dragging');
          sliderEl.classList.remove('dragging');
          setTransform();
        }
      });
    
      // Ресайз
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          const baseSlides = getBaseSlides();
          const realCount = baseSlides.length;
          
          if (getIsMobile()) {
            // На мобилке просто ограничиваем индекс реальными слайдами
            index = Math.min(realCount - 1, Math.max(0, index));
          } else {
            // На десктопе сохраняем текущий реальный индекс для бесконечного слайдера
            const perView = getItemsPerView();
            const edge = Math.min(realCount, perView + 1);
            const realIndex = ((index - edge) % realCount + realCount) % realCount;
            index = edge + realIndex;
          }
          
          buildClones();
          // После buildClones на мобилке индекс должен быть 0
          if (getIsMobile()) {
            index = 0;
          }
          setTransform(true);
        }, 150);
      });
    
      // Инициализация
      const init = () => {
        // Всегда начинаем с индекса 0
        index = 0;
        
        renderItems();
        
        // Ждем, пока DOM обновится и слайды получат правильную ширину
        requestAnimationFrame(() => {
          buildClones();
          // Еще один кадр, чтобы слайды получили ширину
          requestAnimationFrame(() => {
            // Убеждаемся, что на мобилке индекс = 0 (buildClones уже установил, но на всякий случай)
            if (getIsMobile()) {
              index = 0;
            }
            setTransform(true);
          });
        });
      };
    
      init();
      
      // Убеждаемся, что кнопки всегда активны (бесконечный слайдер)
      prevBtn.disabled = false;
      nextBtn.disabled = false;
    }
    
    // Инициализация с несколькими попытками для Tilda
    (function() {
      // Пробуем сразу
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initRecommendationsSlider);
      } else {
        // DOM уже загружен
        initRecommendationsSlider();
      }
      
      // Дополнительная попытка после полной загрузки страницы (для Tilda)
      window.addEventListener('load', () => {
        setTimeout(initRecommendationsSlider, 200);
      });
    })();
    </script>