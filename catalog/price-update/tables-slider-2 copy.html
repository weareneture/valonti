<script>
  // Функция инициализации слайдера (вешалки); при 2 товарах на десктопе — сетка 2 в ряд
  async function initRecommendationsSlider() {
    const PRICES_URL = 'https://raw.githubusercontent.com/weareneture/valonti/refs/heads/main/catalog/price-update/prices.json';
    const IMG_BASE = 'https://raw.githubusercontent.com/weareneture/valonti/refs/heads/main/catalog/img/hanger/';

    // Базовые данные рекомендаций — вешалки (2 товара)
    const recommendationsBase = [
      {
        image: IMG_BASE + 'veilum.png',
        category: 'Вешалка',
        title: 'Veilum',
        productId: 'veilum',
        price: 'Загрузка...',
        link: 'https://valonti.ru/catalog/hanger/veilum'
      },
      {
        image: IMG_BASE + 'fornis.png',
        category: 'Вешалка',
        title: 'Fornis',
        productId: 'fornis',
        price: 'Загрузка...',
        link: 'https://valonti.ru/catalog/hanger/fornis'
      },
    ];

    // Загружаем цены из JSON
    let pricesData = {};
    try {
      const response = await fetch(PRICES_URL + '?t=' + Date.now());
      pricesData = await response.json();
    } catch (error) {
      console.error('Ошибка загрузки цен:', error);
    }

    // Обновляем цены в рекомендациях
    const recommendations = recommendationsBase.map(item => ({
      ...item,
      price: pricesData.prices && pricesData.prices[item.productId]
        ? pricesData.prices[item.productId]
        : item.price
    }));

    const listEl = document.querySelector('[data-recommendations-list]');
    const prevBtn = document.querySelector('.recommendations__nav--prev');
    const nextBtn = document.querySelector('.recommendations__nav--next');
    const trackEl = document.querySelector('[data-recommendations-track]');
    const sliderEl = document.querySelector('[data-recommendations-slider]');

    if (!listEl || !prevBtn || !nextBtn || !sliderEl) {
      setTimeout(initRecommendationsSlider, 100);
      return;
    }

    // На десктопе при 2 товарах — сетка 2 в ряд, без слайдера
    const isGridMode = !window.matchMedia('(max-width: 768px)').matches && recommendations.length <= 2;

    let index = 0;
    let isAnimating = false;

    const getIsMobile = () => window.matchMedia('(max-width: 768px)').matches;
    const getItemsPerView = () => getIsMobile() ? 1 : 2;

    const getBaseSlides = () => Array.from(listEl.querySelectorAll(':scope > .recommendations__item:not(.recommendations__clone)'));
    const getAllSlides = () => Array.from(listEl.querySelectorAll(':scope > .recommendations__item'));

    const createCard = (item) => {
      const card = document.createElement('a');
      card.href = item.link;
      card.className = 'recommendations__item model__item';
      card.draggable = false;
      card.innerHTML = `
        <img src="${item.image}" alt="${item.title}" class="model__img vertical" draggable="false">
        <div class="model__content">
          <div class="model__content__left">
            <p class="model__catname">${item.category}</p>
            <h2 class="model__title">${item.title}</h2>
          </div>
          <div class="model__content__right">
            <p class="model__price">${item.price}</p>
          </div>
        </div>
      `;
      return card;
    };

    const renderItems = () => {
      listEl.innerHTML = '';
      recommendations.forEach((item) => {
        const card = createCard(item);
        listEl.appendChild(card);
      });
    };

    const cloneCard = (card) => {
      const clone = card.cloneNode(true);
      clone.classList.add('recommendations__clone');
      return clone;
    };

    const buildClones = () => {
      listEl.querySelectorAll(':scope > .recommendations__clone').forEach(clone => clone.remove());

      const baseSlides = getBaseSlides();
      if (!baseSlides.length) return;

      if (getIsMobile()) {
        index = 0;
        return;
      }

      const perView = getItemsPerView();
      const needed = Math.min(baseSlides.length, perView + 1);

      const headClones = baseSlides.slice(0, needed).map(cloneCard);
      headClones.forEach(clone => listEl.appendChild(clone));

      const tailClones = baseSlides.slice(-needed).map(cloneCard);
      tailClones.forEach(clone => listEl.insertBefore(clone, listEl.firstChild));

      index = needed;
    };

    const setTransform = (instant = false) => {
      const isMobile = getIsMobile();
      const gap = isMobile ? 8 : 20;

      if (!trackEl || trackEl.offsetWidth === 0) {
        requestAnimationFrame(() => setTransform(instant));
        return;
      }

      const slides = isMobile ? getBaseSlides() : getAllSlides();
      if (slides.length === 0) {
        requestAnimationFrame(() => setTransform(instant));
        return;
      }

      const firstSlide = slides[0];
      if (!firstSlide || firstSlide.offsetWidth === 0) {
        requestAnimationFrame(() => setTransform(instant));
        return;
      }

      const slideWidth = firstSlide.offsetWidth;
      const translateX = -index * (slideWidth + gap);

      if (instant) {
        listEl.style.transition = 'none';
      } else {
        listEl.style.transition = 'transform 0.4s ease';
      }

      listEl.style.transform = `translateX(${translateX}px)`;
    };

    const snapIfLooped = () => {
      if (getIsMobile()) return;

      const baseSlides = getBaseSlides();
      const realCount = baseSlides.length;
      if (!realCount) return;

      const perView = getItemsPerView();
      const edge = Math.min(realCount, perView + 1);
      const total = getAllSlides().length;

      if (index >= total - edge) {
        index = index - realCount;
        setTransform(true);
      } else if (index < edge) {
        index = index + realCount;
        setTransform(true);
      }
    };

    const goPrev = (step = 1) => {
      if (isAnimating || isDragging) return;
      isAnimating = true;

      if (getIsMobile()) {
        index = Math.max(0, index - step);
      } else {
        index -= step;
      }

      setTransform();
      setTimeout(() => {
        snapIfLooped();
        isAnimating = false;
      }, 400);
    };

    const goNext = (step = 1) => {
      if (isAnimating || isDragging) return;
      isAnimating = true;

      const baseSlides = getBaseSlides();
      const realCount = baseSlides.length;

      if (getIsMobile()) {
        index = Math.min(realCount - 1, index + step);
      } else {
        index += step;
      }

      setTransform();
      setTimeout(() => {
        snapIfLooped();
        isAnimating = false;
      }, 400);
    };

    prevBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      goPrev();
    });

    nextBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      goNext();
    });

    let dragStartX = 0;
    let dragStartY = 0;
    let dragCurrentX = 0;
    let dragCurrentY = 0;
    let isDragging = false;
    let startTranslateX = 0;

    const onPointerDown = (e) => {
      if (e.pointerType === 'mouse' && e.button !== 0) return;
      if (isAnimating) return;

      if (e.target && typeof e.target.closest === 'function' && e.target.closest('.recommendations__nav')) return;

      const isTouch = e.pointerType === 'touch' || e.pointerType === 'pen';
      if (!isTouch) {
        e.preventDefault();
      }

      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      dragCurrentX = e.clientX;
      dragCurrentY = e.clientY;

      const transform = listEl.style.transform;
      const match = transform.match(/translateX\((-?\d+\.?\d*)px\)/);
      startTranslateX = match ? parseFloat(match[1]) : 0;

      listEl.classList.add('dragging');
      sliderEl.classList.add('dragging');
      listEl.style.transition = 'none';
      try { sliderEl.setPointerCapture(e.pointerId); } catch (_) {}
    };

    const onPointerMove = (e) => {
      if (!isDragging) return;

      dragCurrentX = e.clientX;
      dragCurrentY = e.clientY;
      const deltaX = dragCurrentX - dragStartX;
      const deltaY = dragCurrentY - dragStartY;

      const isTouch = e.pointerType === 'touch' || e.pointerType === 'pen';
      if (isTouch) {
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 5) {
          e.preventDefault();
        }
      } else {
        e.preventDefault();
      }

      const newTranslateX = startTranslateX + deltaX;
      listEl.style.transform = `translateX(${newTranslateX}px)`;
    };

    const onPointerUp = (e) => {
      if (!isDragging) return;
      isDragging = false;
      listEl.classList.remove('dragging');
      sliderEl.classList.remove('dragging');

      const dx = dragCurrentX - dragStartX;
      const dy = dragCurrentY - dragStartY;
      const threshold = 30;

      const isHorizontal = Math.abs(dx) > Math.abs(dy);
      const isMobile = getIsMobile();

      if (isHorizontal && Math.abs(dx) > threshold) {
        e.preventDefault();
        if (dx < 0) goNext();
        else goPrev();
      } else {
        let clickedCard = null;
        if (e.target && typeof e.target.closest === 'function') {
          clickedCard = e.target.closest('.recommendations__item');
        } else if (e.target) {
          let el = e.target;
          while (el && el !== document) {
            if (el.classList && el.classList.contains('recommendations__item')) {
              clickedCard = el;
              break;
            }
            el = el.parentElement;
          }
        }

        if (clickedCard && !clickedCard.classList.contains('recommendations__clone') && Math.abs(dx) < 10) {
          setTimeout(() => {
            if (clickedCard.href) {
              window.location.href = clickedCard.href;
            }
          }, 10);
        } else {
          setTransform();
        }
      }
    };

    const handlePointerDown = (e) => {
      if (e.target.closest('.recommendations__nav')) return;
      onPointerDown(e);
    };

    sliderEl.addEventListener('pointerdown', handlePointerDown, { passive: false });
    sliderEl.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1 && !isDragging && !isAnimating) {
        const touch = e.touches[0];
        const target = e.target;
        const fakeEvent = {
          pointerType: 'touch',
          clientX: touch.clientX,
          clientY: touch.clientY,
          button: 0,
          target: target,
          preventDefault: () => e.preventDefault(),
          stopPropagation: () => e.stopPropagation()
        };
        if (!fakeEvent.target.closest) {
          fakeEvent.target.closest = function(selector) {
            let el = this;
            while (el && el !== document) {
              if (el.matches && el.matches(selector)) return el;
              el = el.parentElement;
            }
            return null;
          };
        }
        handlePointerDown(fakeEvent);
      }
    }, { passive: false });

    const handlePointerMove = (e) => onPointerMove(e);
    const handlePointerUp = (e) => onPointerUp(e);

    document.addEventListener('pointermove', handlePointerMove, { passive: false });
    document.addEventListener('pointerup', handlePointerUp, { passive: false });

    document.addEventListener('touchmove', (e) => {
      if (isDragging && e.touches.length === 1) {
        const touch = e.touches[0];
        const fakeEvent = {
          pointerType: 'touch',
          clientX: touch.clientX,
          clientY: touch.clientY,
          preventDefault: () => e.preventDefault()
        };
        handlePointerMove(fakeEvent);
      }
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
      if (isDragging) {
        const touch = e.changedTouches[0];
        const target = e.target;
        const fakeEvent = {
          pointerType: 'touch',
          clientX: touch.clientX,
          clientY: touch.clientY,
          target: target,
          preventDefault: () => e.preventDefault()
        };
        if (!fakeEvent.target.closest) {
          fakeEvent.target.closest = function(selector) {
            let el = this;
            while (el && el !== document) {
              if (el.matches && el.matches(selector)) return el;
              el = el.parentElement;
            }
            return null;
          };
        }
        handlePointerUp(fakeEvent);
      }
    }, { passive: false });

    document.addEventListener('touchcancel', () => {
      if (isDragging) {
        isDragging = false;
        listEl.classList.remove('dragging');
        sliderEl.classList.remove('dragging');
        setTransform();
      }
    });

    document.addEventListener('pointercancel', () => {
      if (isDragging) {
        isDragging = false;
        listEl.classList.remove('dragging');
        sliderEl.classList.remove('dragging');
        setTransform();
      }
    });

    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const baseSlides = getBaseSlides();
        const realCount = baseSlides.length;

        if (getIsMobile()) {
          index = Math.min(realCount - 1, Math.max(0, index));
        } else {
          const perView = getItemsPerView();
          const edge = Math.min(realCount, perView + 1);
          const realIndex = ((index - edge) % realCount + realCount) % realCount;
          index = edge + realIndex;
        }

        buildClones();
        if (getIsMobile()) {
          index = 0;
        }
        setTransform(true);
      }, 150);
    });

    const init = () => {
      index = 0;

      renderItems();

      if (isGridMode) {
        sliderEl.classList.add('recommendations--grid');
        listEl.classList.add('recommendations__list--grid');
        prevBtn.style.display = 'none';
        nextBtn.style.display = 'none';
        return;
      }

      requestAnimationFrame(() => {
        buildClones();
        requestAnimationFrame(() => {
          if (getIsMobile()) {
            index = 0;
          }
          setTransform(true);
        });
      });
    };

    init();

    prevBtn.disabled = false;
    nextBtn.disabled = false;
  }

  (function() {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initRecommendationsSlider);
    } else {
      initRecommendationsSlider();
    }

    window.addEventListener('load', () => {
      setTimeout(initRecommendationsSlider, 200);
    });
  })();
</script>


<style> 
  /* Слайдер рекомендаций */
  .section__recommendations {
    /*padding: 0px 24px;*/
    max-width: 1000px;
    margin: 0 auto;
  }
  
  .container__recommendations {
    width: 100%;
  }
  
  .recommendations__title {
    margin: 0 0 32px;
    color: #fff;
    font-family: "RF Dewi";
    font-size: 24px;
    font-style: normal;
    font-weight: 400;
    line-height: 28px;
    text-align: center;
  }
  
  .recommendations__slider {
    position: relative;
    display: flex;
    align-items: center;
    gap: 16px;
    overflow: visible; /* чтобы стрелки были видны */
    cursor: grab;
    user-select: none;
  }
  
  .recommendations__slider:active {
    cursor: grabbing;
  }
  
  .recommendations__slider.dragging {
    cursor: grabbing;
  }
  
  .recommendations__track {
    flex: 1;
    overflow: visible; /* видим части следующих карточек */
    position: relative;
  }
  
  .recommendations__list {
    display: flex;
    gap: 20px;
    transition: transform 0.4s ease;
    will-change: transform;
    align-items: center;
  }

  /* Режим сетки: 2 товара в 1 строку на десктопе */
  .recommendations__list--grid {
    display: grid !important;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    transform: none !important;
    will-change: auto;
  }

  .recommendations--grid .recommendations__nav {
    display: none !important;
  }

  .recommendations__list--grid .recommendations__item {
    width: 100%;
    max-width: none;
    min-width: 0;
  }
  
  .recommendations__list.dragging {
    transition: none;
  }
  
  .recommendations__item {
    flex: 0 0 auto;
    width: calc((26.2% - 20px) / 2); /* 2 карточки на десктопе: (100% - gap) / 2 */
    min-width: calc((26.2% - 20px) / 2);
    max-width: calc((100% - 20px) / 2);
  }
  
  
  /* Стили карточек из каталога для слайдера */
  .recommendations__item.model__item {
    overflow: hidden;
    display: flex;
    /*max-width: 148px;*/
    max-width: 57.8px;
    height: 300px;
    padding: 20px;
    position: relative;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 8px;
    border-radius: 8px;
    background: #181818;
    transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
    cursor: grab;
    text-decoration: none;
    -webkit-user-drag: none;
    user-select: none;
  }
  
  .recommendations__item.model__item:active {
    cursor: grabbing;
  }
  
  .recommendations__item.model__item:hover {
    transform: scale(1.02);
  }
  
  .recommendations__item .model__img {
    height: 90%;
    width: auto;
    object-fit: contain;
    pointer-events: none;
    -webkit-user-drag: none;
    user-select: none;
    -webkit-touch-callout: none;
  }
  
  .recommendations__item .model__content {
    position: absolute;
    left: 20px;
    right: 20px;
    bottom: 20px;
    width: calc(100% - 40px);
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
  }
  
  .recommendations__item .model__content__left {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  
  .recommendations__item .model__catname {
    color: rgba(255, 255, 255, 0.60);
    font-family: "RF Dewi";
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 16px;
    margin: 0;
  }
  
  .recommendations__item .model__title {
    color: #FFF;
    font-family: "RF Dewi";
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: 18px;
    text-transform: uppercase;
    margin: 0;
  }
  
  .recommendations__item .model__price {
    color: #FFF;
    font-family: "RF Dewi";
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 16px;
    margin: 0;
  }
  
  .recommendations__nav {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 38px;
    height: 48px;
    border-radius: 50%;
    border: 1.2px solid rgba(255, 255, 255, 0.15);
    background: transparent;
    color: #fff;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease;
    flex-shrink: 0;
    z-index: 10; /* чтобы стрелки были поверх */
  }
  
  .recommendations__nav:hover {
    transform: translateY(-50%) scale(1.05);
  }
  
  .recommendations__nav:active {
    transform: translateY(-50%) scale(0.98);
  }
  
  .recommendations__nav--prev {
    left: -60px;
  }
  
  .recommendations__nav--next {
    right: -60px;
  }
  
  
  .recommendations__nav:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    pointer-events: none;
  }
  
  .recommendations__nav-icon {
    margin-top: -4px;
    font-size: 18px;
    line-height: 1;
    position: relative;
    z-index: 1;
  }
  
  @media (max-width: 768px) {
    .section__recommendations {
      padding: 0;
      overflow: visible; /* не блокируем видимость соседних карточек */
    }
  
    .container__recommendations {
      overflow: visible; /* не блокируем видимость соседних карточек */
      width: 100%; /* занимает всю ширину контентной зоны */
      max-width: 100%; /* не превышает ширину контентной зоны */
    }
  
    .recommendations__title {
      font-size: 20px;
      margin-bottom: 24px;
      padding: 0 16px;
    }
  
    .recommendations__slider {
      gap: 0;
      touch-action: pan-x; /* разрешаем горизонтальный свайп */
      -webkit-overflow-scrolling: touch;
    }
  
    .recommendations__nav {
      display: none; /* скрываем кнопки на мобилке */
    }
  
    .recommendations__track {
      overflow: visible; /* показываем части соседних карточек */
      touch-action: pan-x; /* разрешаем горизонтальный свайп */
    }
  
    .recommendations__list {
      gap: 8px;
      touch-action: pan-x; /* разрешаем горизонтальный свайп */
      margin: 0; /* убираем возможные отступы */
      padding: 0; /* убираем возможные отступы */
    }
  
    .recommendations__item.model__item {
      max-width: 151px;
    }
      
    .recommendations__item {
      width: 290px;
      max-width: 290px;
      /*width: 26.2%; /* ширина определяется содержимым */
      /*min-width: 26.2%; /* минимальная ширина для видимости соседних */
      flex-shrink: 0;
      touch-action: pan-x; /* разрешаем горизонтальный свайп */
    }
  
    .recommendations__item.model__item {
      height: 200px;
      padding: 16px;
      -webkit-tap-highlight-color: transparent; /* убираем подсветку при тапе на мобилке */
      touch-action: pan-x; /* разрешаем горизонтальный свайп */
    }
  
    .recommendations__item .model__content {
      left: 16px;
      right: 16px;
      bottom: 16px;
      width: calc(100% - 32px);
    }
  
    .recommendations__item .model__content__left {
      gap: 2px;
    }
  
    .recommendations__item .model__catname {
      font-size: 10px;
    }
  
    .recommendations__item .model__title,
    .recommendations__item .model__price {
      font-size: 12px;
    }
  
    .recommendations__item.model__item:hover {
      transform: none;
    }
  
    .recommendations__nav {
      display: none; /* убираем стрелки на мобилке */
    }

    .recommendations__list--grid {
      grid-template-columns: 1fr; /* одна колонка на мобилке */
    }
  }
  </style>

<section class="section__recommendations">
  <div class="container__recommendations">
    <div class="recommendations__slider" data-recommendations-slider>
      <button class="recommendations__nav recommendations__nav--prev" type="button" aria-label="Предыдущий">
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="8" viewBox="0 0 18 8" fill="none">
              <path d="M17 3.76575C17.2761 3.76575 17.5 3.9896 17.5 4.26575C17.5 4.54189 17.2761 4.76575 17 4.76575V4.26575V3.76575ZM0.646447 4.6193C0.451184 4.42404 0.451184 4.10746 0.646447 3.91219L3.82843 0.730213C4.02369 0.534951 4.34027 0.534951 4.53553 0.730213C4.7308 0.925475 4.7308 1.24206 4.53553 1.43732L1.70711 4.26575L4.53553 7.09417C4.7308 7.28944 4.7308 7.60602 4.53553 7.80128C4.34027 7.99654 4.02369 7.99654 3.82843 7.80128L0.646447 4.6193ZM17 4.26575V4.76575H1V4.26575V3.76575H17V4.26575Z" fill="white"/>
            </svg>
      </button>
      
      <div class="recommendations__track" data-recommendations-track>
        <div class="recommendations__list" data-recommendations-list>
          <!-- Карточки будут добавлены через JS -->
        </div>
      </div>
      
      <button class="recommendations__nav recommendations__nav--next" type="button" aria-label="Следующий">
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="8" viewBox="0 0 18 8" fill="none">
              <path d="M0.935913 3.76575C0.659771 3.76575 0.435913 3.9896 0.435913 4.26575C0.435913 4.54189 0.659771 4.76575 0.935913 4.76575V4.26575V3.76575ZM17.2895 4.6193C17.4847 4.42404 17.4847 4.10746 17.2895 3.91219L14.1075 0.730213C13.9122 0.534951 13.5956 0.534951 13.4004 0.730213C13.2051 0.925475 13.2051 1.24206 13.4004 1.43732L16.2288 4.26575L13.4004 7.09417C13.2051 7.28944 13.2051 7.60602 13.4004 7.80128C13.5956 7.99654 13.9122 7.99654 14.1075 7.80128L17.2895 4.6193ZM0.935913 4.26575V4.76575H16.9359V4.26575V3.76575H0.935913V4.26575Z" fill="white"/>
            </svg>
      </button>
    </div>
  </div>
</section>